{
    "collab_server" : "",
    "contents" : "################################################################\n#\n# Main GA function\n# Xu, Weijie; Chen, Yuwen; Adams, Cameron; Zhou, Yilin\n#\n# Final Projct\n# STAT 243\n# Fall 2017\n#\n################################################################\n\n#' Variable selection using genetic algorithms\n#'\n#' select implements genetic algorithms for variable selection for GLMs by optimizing package or user specified objective functions such as AIC, BIC, and logloglikelihood.\n#' Uses functions: \\code{\\link{generate_founders}}, \\code{\\link{evaluate_fitness}}, and \\code{\\link{create_next_generation}}.\n#' Functions find optimal variables by using evolutationry biology concepts of natural selection, fitness, genetic crossover, and mutation. Founding generation of chromosomes is randomly generated and evaluated using an critieria such as AIC, BIC, or loglihood. Parents are selected by their fitness, and generate children chromosomes. As each generation breeds and produces new genreations, the algorithm moves towards the optimum.\n#'\n#' 1. Geof H. Givens, Jennifer A. Hoeting (2013) Combinatorial Optimization (italicize). Chapter 3 of Computational Statistics (italicize).\n#'\n#' @param Y vector of response variable\n#' @param X a matrix or dataframe of predictor variables\n#' @param family a character string describing the error distribution and link function to be used in the model. Default is gaussian.\n#' @param objective_function function for computing objective. Default is \\code{\\link{AIC}}. User can specify custom function.\n#' @param crossover_parents_function a function for crossover between mate pairs. User can specify custom function. Default is \\code{\\link{crossover_parents}}.\n#' @param crossover_method a character string describing crossover method. Default is multi-point crossover. See \\code{\\link{crossover_parents}}.\n#' @param pCrossover a numeric value for he probability of crossover for each mate pair.\n#' @param start_chrom a numeric value for the  size of the popuation of chromosomes. Default is \\code{choose(C, 2)} \\eqn{\\le 200}, where C is number of predictors.\n#' @param mutation_rate a numeric value for rate of mutation. Default is \\eqn{1 / (P \\sqrt C)}, where P is number of chromosomes, and C is number of predictors.\n#' @param converge a logical value indicating whether algorithm should attempt to converge or run for specified number of iterations. If \\code{TRUE}, convergence will occur when highest ranked chromosomes is equal to mean of top 50\\% in current and previous generation.\n#' @param tol a numeric value indicating convergence tolerance. Default is 1e-4.\n#' @param iter an integer specifying maximum number of generations algorithm will produce. Default is 100\n#' @param minimize a logical value indicating whether optimize should be minimized (TRUE) or maximized (FALSE).\n#' @param nCores an integer indicating number of parallel processes to run when evaluating fitness. Default is 1, or no paralleization. See \\code{\\link{evaluate_fitness}}.\n#'\n#'If user wants to use custom objective_function, they must use a function that is compatible with \\code{\\link{lm}} or \\code{\\link{glm}} fitted objects which output a numberic value of length 1.\n#'\n#' @examples\n#' # Simulated data\n#' rm(list = ls())\n#'\n#' set.seed(1111)\n#'\n#' # simulate data for gaussian GLM\n#' library(simrel)\n#' library(GA)\n#'\n#' n <- 100 # number obs\n#' p <- 10 # number predictors\n#' m <- 2 # number relevant latent components\n#' q <- 5 # number relevant predictors\n#' gamma <- 0.2 # speed of decline in eigenvalues\n#' R2 <- 0.5 # theoretical R-squared according to the true linear model\n#' relpos <- base::sample(1:p, m, replace = FALSE) # positions of m\n#' dat <- simrel::simrel(n, p, m, q, relpos, gamma, R2) # generate data\n#' x <- dat$X\n#' y <- dat$Y\n#'\n#' \\dontrun{sim_GA <- GA:select(y, x, family = \"gaussian\", objective_function = stats::AIC,\n#' crossover_method = \"method1\", pCrossover = 0.8, converge = TRUE, minimize = TRUE, nCores = 1)}\n#'\n#' # mtcars\n#' data(mtcars)\n#'\n#' y <- mtcars$mpg\n#' x <- mtcars[, 2:11]\n#'\n#' \\dontrun{GA_mtcars <- GA:select(y, x, family = \"gaussian\", objective_function = stats::AIC,\n#' crossover_method = \"method1\", pCrossover = 0.8, converge = TRUE, minimize = TRUE, nCores = 1)}\n#'\n#'\n#' @export\n\nselect <- function(Y, X, family = \"gaussian\",\n                  objective_function = stats::AIC,\n                  crossover_parents_function = crossover_parents,\n                  crossover_method = c(\"method1\", \"method2\", \"method3\"),\n                  pCrossover = 0.8,\n                  start_chrom = NULL,\n                  mutation_rate = NULL,\n                  converge = TRUE,\n                  tol = 1e-4,\n                  iter = 100,\n                  minimize = TRUE,\n                  nCores = 1L) {\n\n\n\n    ########\n    #error checking\n    ########\n\n    # X\n    if (missing(X)) stop(\"Error: must input a matrix of predictor data\")\n    if (!is.matrix(X) & !is.data.frame(X)) stop(\"X must be matrix or dataframe\")\n\n    # Y\n    if (missing(Y)) stop(\"Error: must input a vector of reponse data\")\n    if (!is.vector(Y) & !is.matrix(Y)) stop(\"Y must be vector or 1 column matrix\")\n    if (is.matrix(Y) | is.data.frame(Y)) {\n        if(ncol(Y) > 1) stop(\"Y must be vector or 1 column matrix\")\n    }\n    if (length(Y) != dim(X)[1]) stop(\"Error: X and Y dimensions don't match\")\n\n    # family\n    if (family == \"gaussian\" & all(Y %% 1 == 0)) {cat(\"Warning: outcome distribution is are 1, 0 integer, family == 'gaussian' may not be suitable\")}\n    if (family == \"gamma\" & sum(Y > 0) > 0) {cat(\"Warning: outcome values < 0, family == 'gamma' may produce errors\")}\n    if (!family %in% c(\"gaussian\", \"binomial\", \"gamma\", \"poisson\")) stop(\"Error: family argument misspecified\")\n\n    # objective_function\n    if (!is.function(objective_function)) stop(\"Error: objective_function must be a function\")\n\n    # crossover_parents\n    if (!is.function(crossover_parents_function)) stop(\"Error: crossover_parents must be a function\")\n\n    # crossover_method\n    if (!is.character(crossover_method)) stop(\"Error: crossover_method should be a character string\")\n    if (length(crossover_method) > 1) crossover_method <- crossover_method[1]\n    if (!crossover_method %in% c(\"method1\", \"method2\", \"method3\")) stop(\"Error: incorrect crossover method misspecified\")\n\n    # pCrossover\n    if (!is.numeric(pCrossover) | pCrossover < .Machine$double.eps | pCrossover > 1) stop(\"Error: pCrossover must be number between 0 and 1\")\n    if (pCrossover < 0.5) cat(\"Warning: pCrossover < 0.5 may not reach optimum\")\n\n    # mutation_rate\n    if (!is.null(mutation_rate)) {\n        if(!is.numeric(mutation_rate)) stop(\"Error: mutation rate must be numeric\")\n        if(mutation_rate < 0 | mutation_rate > 1) stop(\"Error: mutation rate must be bewteen 0 and 1\")\n    }\n\n    # converge\n    if (!is.logical(converge)) stop(\"Error: converge must be logical (TRUE/FALSE). Default is TRUE\")\n\n    # tol\n    if (!is.numeric(tol)) stop(\"Error: tol must be numeric. Default is 1e-4\")\n\n    # iter\n    if (!is.numeric(iter)) stop(\"Error: iter must be numeric\")\n    if (length(iter) > 1) stop(\"Error: iter be of length one\")\n\n    # minimize\n    if (!is.logical(minimize)) stop(\"Error: minimize must be logical (TRUE/FALSE). Default is TRUE\")\n\n    # nCores\n    if (!is.integer(nCores)) stop(\"Error: nCores must be integer of length 1\")\n    if (nCores > parallel::detectCores()) stop(\"Error: nCores cannot be larger than detectCores()\")\n    if (nCores < 1) stop(\"Error: nCores must be >= 1\")\n\n\n    ##########\n    # Perform genetic algorithm\n    #########\n    t1 <- Sys.time() # timing\n\n    # Step 1: Generate founders ----------------\n    generation_t0 <- generate_founders(X, start_chrom)\n    P <- nrow(generation_t0) #num chromosomes\n    cat(\"1. Generate founders: \", P, \"chromosomes\")\n\n\n    # Step 2. Evaluate founder fitness Fitness of inital pop ----------------\n    cat(\"\\n2. Evaluate founders\")\n    obj_fun_output_t0 <- evaluate_fitness(generation_t0, Y, X,\n                                        family,\n                                        nCores, minimize,\n                                        objective_function,\n                                        rank_objective_function)\n\n    #create array to store fitness data for each iteration\n    convergeData <- array(dim = c(P, 2, 1)) #P x 2 x iter\n\n    #save founder fitness evaluation data\n    convergeData[, , 1] <- obj_fun_output_t0[\n                            order(obj_fun_output_t0[, 2], decreasing = T),\n                            c(1, 3)]\n\n    # Step 3. loop through successive generations  ----------------\n    cat(\"\\n3. Begin breeding \\n Generations: \")\n    t1 <- c(t1, Sys.time())\n    for (i in 1:iter) {\n\n        # 1. create next generation ----------------\n        if (i == 1) {\n            generation_t1 <- generation_t0\n            obj_fun_output_t1 <- obj_fun_output_t0\n        }\n\n        generation_t1 <- create_next_generation(generation_t1,\n                                            obj_fun_output_t1,\n                                            select_parents,\n                                            crossover_method,\n                                            crossover_parents_function,\n                                            pCrossover,\n                                            mutate_child,\n                                            mutation_rate)\n\n        # 2. evaluate children fitness ----------------\n        obj_fun_output_t1 <- evaluate_fitness(generation_t1, Y, X,\n                                            family,\n                                            nCores, minimize,\n                                            objective_function,\n                                            rank_objective_function)\n\n        # store fitness data\n        convergeData <- abind::abind(convergeData,\n                                obj_fun_output_t1[order(obj_fun_output_t1[, 2],\n                                decreasing = T), c(1, 3)])\n\n        # cat generation and save timing\n        cat(i, \"-\", sep = \"\")\n\n        # 3. check convergence ----------------\n        if (i > 10 & isTRUE(converge)) {\n            if(isTRUE(all.equal(mean(convergeData[1:(P * 0.25), 2, i]),\n                                convergeData[1, 2, i],\n                                check.names = F,\n                                tolerance = tol)) &\n               isTRUE(all.equal(mean(convergeData[1:(P * 0.25), 2, (i - 1)]),\n                                convergeData[1, 2, i],\n                                check.names = F,\n                                tolerance = tol))) {\n\n            #if((abs(convergeData[1, 2, i] - convergeData[1, 2, (i - 1)]) /\n            #          abs( convergeData[1, 2, (i - 1)])) < tol) {\n                cat(\"\\n#### Converged! ####\")\n                break\n            }\n        }\n    }\n\n    # Step 4. process output ----------------\n    t1 <- c(t1, Sys.time())\n\n    # get models with the best fitness\n    best_scores <- convergeData[, , i]\n    if (sum(best_scores[, 2] == best_scores[1, 2]) > 1) {\n        num_best_scores <- sum(best_scores[, 2] == best_scores[1, 2])\n    } else {num_best_scores <- 1}\n    bestModel <- generation_t1[convergeData[, 1, i], ]\n\n    # other output information\n    value <- convergeData[1, 2, dim(convergeData)[3]]\n    if(dim(convergeData)[3] < iter) {converged <- \"Yes\"\n    } else {converged <- \"No\"}\n\n    # create output list\n    output <- list(\"Best_model\" =\n                       colnames(X)[round(colMeans(bestModel[1:dim(best_scores)[1], ]), 0) == 1],\n                    optimize = list(\"obj_func\" = paste(substitute(objective_function))[3],\n                                value = as.numeric(round(value, 4)),\n                                minimize = minimize,\n                                method = crossover_method),\n                    iter = dim(convergeData)[3] - 1,\n                    converged = converged,\n                   convergeData = convergeData,\n                   timing = t1)\n\n    # set class\n    class(output) <- c(\"GA\", class(output))\n\n    return(output)\n}\n\n\n",
    "created" : 1513167830120.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1402711571",
    "id" : "2122B2BF",
    "lastKnownWriteTime" : 1513235081,
    "last_content_update" : 1513235081459,
    "path" : "~/repos/STAT243/project/GA/R/select.R",
    "project_path" : "R/select.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}